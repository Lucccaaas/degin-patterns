#+TITLE: Design Pattern

* 设计模式分类
** 创建型模式
  - 工厂方法模式
  - 抽象工厂模式
  - 单例模式
  - 建造者模式
  - 原型模式
** 结构性模式
  - 适配器模式
  - 装饰器模式
  - 代理模式
  - 外观模式
  - 桥接模式
  - 组合模式
  - 享元模式
** 行为型模式
  - 策略模式
  - 模版方法模式
  - 观察者模式
  - 迭代子模式
  - 责任连模式
  - 命令模式
  - 备忘录模式
  - 状态模式
  - 访问者模式
  - 中介模式
  - 解释器模式
** 并发型模式
** 线程池模式

* 设计模式的六大原则
** 单一职责原则(single responsbility)
  - 一个类，一个函数，一个模块，一个功能块一次只做一件事情
  - 好处是便于维护，和测试。状态的叠加产生的状态数是一个指数函数。
** 里氏替换原则(Liskov Substitution Principle)
  - 定义： 里氏代换原则是对实现抽象化的具体步骤的规范
  - 若不存在扩展继承，便不会存在替换问题。
  - 若存在扩展继承，子类应尽量不要重写和重载父类方法
** 依赖倒转原则(Dependence Inversion Principle)
  - 面向接口编程，依赖抽象而非具体实现。
  - 没什么好说的，尽量使用实现继承。
** 接口隔离原则(Interface Segregation Principle)
  - 定义：每个接口不存在子类用不到却必须实现的方法。如果存在，应该将接口拆分为多个接口。
** 迪米特(最少知道)法则(Demeter Principle)
  - 定义A：一个类，模块，功能块，对自己依赖的类知道得越少越好。也就是说无论被依赖的类多么复杂，
    都应该将实现封装在内部。
  - 定义B：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合。
** 合成复用原则(Composite Reuse Principle)
  - 尽量使用组合／聚合，而不是使用继承。

* 23种设计模式
** 创建模式
*** 简单工厂模式
**** 普通工厂
  - 工厂类有一个可以生产一系列具有一定约束的对象的方法
**** 多个方法
  - 两个工厂的工厂方法放到一个类里就是多方法工厂
**** 多个静态方法
  - 实例方法变为静态方法
*** 工厂方法模式(Factory Method)
  - 简单工厂类的创建依赖工厂类，当拓展程序时，必须对工厂类进行修改。
  - 利用一个工厂接口和一个产品接口，将程序改变时的修改从工厂类转变为实现类的增加。
  - 原先的基于if else的类型判断分发对象 变为 语言本身内建的基于入参类型的multi dispatch。
*** 抽象工厂模式(Abstract Factory)
  - 工厂方法模式
    - 一个抽象产品类，多个具体产品类
    - 一个抽象工厂类，多个具体工厂类
  - 抽象工厂模式
    - 多个抽象产品类，每个抽象产品类有多个具体产品类
    - 一个抽象工厂类，多个具体工厂类
*** 单例模式(Singleton)
  - 定义: 保证在一个系统中，只存在有限个对象。
  - 好处
    - 降低频繁创建的类产生的开销，以及gc压力
    - 系统的约束中只存在有限个对象
  - 线程安全问题
    - 在多线程环境下，对产生单例对象的方法加锁。
    - 优化，将加锁时机从get对象时延迟到新建对象时。但在JVM优化的情况下，赋值和实例化是分两步进行，还可能会出现错误。
    - 利用JVM加载类时线程互斥的机制，利用内部类实现。
    - 继续优化，将判断与新建类拆分开。并对新建类的方法加锁。
*** 建造者模式(Builder)
  - 采用内部类是我见过比较优雅的方式了，lombok就是这么做的。
*** 原型模式(Prototype)
  - 说明: 原型模式虽然是创建型模式，但是与工程模式没有关系，该模式的思想是将一个对象作为原型，
    对其进行复制、克隆，产生一个和原对象类似的新对象。
  - 深复制: 将对象的二进制输入以流的形式读入，再写出二进制数据对应的对象.
    - ObjectOutputStream<ByteArrayOutputStream>.write(Object) -> ()
    - ObjectInputStream<ByteArrayOutputStream<ByteArray>>.readObject() -> Object
** 结构模式
*** 适配器模式(Adapter)
  - 将某个接口转换成另外一个接口表示。
**** 类的适配器模式
  - 核心思想: Source类，拥有一个待适配的方法A，目标接口Targetable，
    通过Adapter类，将Source的功能扩展到Targetable里——继承Source，实现Targetable。
**** 对象的适配器模式
  - 思路: Adapter类，不继承Source，而是持有Source类的实例，以解决兼容性.
  - class Wrapper<Source> implements Targetable {}
**** 接口的适配器模式
  - 思路: 借助一个抽象类，实现该接口的所有方法，然后借助一个类，继承该抽象类，重写我们需要的方法。
*** 装饰模式(Decorator)
  - 说明: 动态的给一个对象增加一些新的功能，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。
  - Decorator持有原对象的实例，重新实现需要装饰的方法。
*** 代理模式(Proxy)
  - 说明：用代理类转发请求。代理类对原对象产生的结果再做一些处理。
*** 外观模式(Facade)
  - 不用多说，就是将多个依赖集中到一起，再一起暴露出去。
*** 桥接模式(Bridge)
  - 说明： 把事物和具体实现分开，使他们可以各自独立的变化。
    用意是将抽象化和实现化解耦，使二者可以独立变化。
  - 利用一个接口，将具体的关注点隔离出去。
  - 例子: Client --> DriverManager --> Driver(MySqlDiver | OracleDriver | DB2Driver)
*** 组合模式(Composite)
  - 说明: 又叫部分-整体模式
  - 使用场景: 将多个对象组合在一起进行操作，常用于表示树形结构，如二叉树，数等
*** 享元模式(Flyweight)
  - 说明： 主要目的是实现对象的共享，即共享池。当系统对象多的时候可以减少内存开销。通常与工厂模式一起使用。
  - 将公共属性抽离到一定范围内的公共区域。
** 关系模式（行为型模式）
*** 父类与子类
**** 策略模式(Strategy)
  - 说明: 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换。
  - 每个策略类相当于一个匿名函数.
**** 模板方法模式(Tempalate Method)
  - 说明: 一个抽象类，有一个主方法，再定义n个小方法，可以是抽象也可以是具体的，
    在主方法内组合各个小方法的调用顺序
*** 两个类之间
**** 观察者模式(Observable)
  - 将响应者(观察者)的一部分控制权交给变化源(被观察者)
**** 迭代子模式(Iterator)
  - 提供一个接口Iterator，方便的进行迭代
    #+BEGIN_SRC java
    interface Iterator {
       Object next();
       boolean hasNext();
    }
    #+END_SRC
  - 当前状态在next()中修改
**** 责任链模式(Chain of Responsibility)
  - 说明:有多个对象，每个对象持有下一个对象的饮用，这样就形成一条链，
    请求在这条链上传递，知道某一个对象决定处理该请求。但是发出着并不
    清楚到底最终那个对象会处理该请求，所以责任连模式可以实现，在隐瞒
    客户端的情况下，对系统进行动态的调整。
  - 链接上的请求可以是一个条链，可以是一个树，一个环。
  - 命令只允许由一个对象传给另一个对象，而不允许传给多个对象。
**** 命令模式(Command)
  - 说明: 命令模式很好理解，举个例子，司令员下令让士兵去干件事情，
    从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，
    传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，
    任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，
    不会去关注到底士兵是怎么实现的。
  - 三个角色: Invoker, Receiver, MyCommand。MyCommand实现Command接口，持有接收对象。
  - Invoker<MyCommand<Receiver>>.
*** 类的状态
**** 备忘录模式(Memento)
  - 说明: 主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象。
  - 存在三个类，原始类A，备忘录类B，存储备忘录类C。
  - Original<Value>, Memento<Value>, Storage<Memento<Value>>
**** 状态模式
  - 说明: 当对象的状态改变时，同时改变其行为
  - Context<State<Value>>
*** 通过中间类
**** 访问者模式(Visitor)
  - 访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。
  - 访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。
    若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。
  - 访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。
    访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。
  - 其缺点就是增加新的数据结构很困难。
  - Subject<Visitor>
**** 中介者模式(Mediator)
**** 解释器模式
  - data Expression = Expression | Num
  - Expression<Context<Param1, Param2>>
  - 将操作符表示为一个类。Expression属于非终结符，Prams属于终结符
